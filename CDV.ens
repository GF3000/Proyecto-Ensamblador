;Autor: Guillermo Franco Gimeno
;Fecha: 9/11/2022

;Macros
LEA: MACRO (reg,ETIQ)
	 or	  reg, r0, low(ETIQ)
	 or.u reg, reg, high(ETIQ)
	 ENDMACRO

DBNZ: MACRO (reg, ETIQ)
		sub	reg, reg, 1
		cmp r2, reg, r0
		bb0 eq, r2, ETIQ
		ENDMACRO

LOAD: MACRO (reg, ETIQ)
		LEA (reg, ETIQ)
		ld reg,reg,r0
		ENDMACRO

PUSH: MACRO (ra)
		subu r30, r30,4
		st ra,r30,r0
		ENDMACRO

POP: MACRO (ra)
		ld ra, r30, 0
		addu r30, r30, 4
		ENDMACRO
;Fin Macros

;Datos
org 100
C1:
    data "_"; pos in cad1 = 0x12 pos cad2 = 0xd
cad1:
    data "123okbXbDvMUGAGcbG_]Nwea_xiOIAtW]fjUtpQxO^DvgbO_anBXI]tgqoEYJpyazVLXOzP_NiTrSHnC[wy`ZZRSD`iUFo^zs^lhwubzggh^UXkcORtMCSF"; long =  0x77
from1: 
    data 0
to1: 
    data 6
cad2:
    data "121`fnZngg^ni_L_kYOfoqGIU[jZHzDXIbhDy[hE`y"; long = 0x2a
    
cad3:
    data "912i123cm123";  BUscaMax = 4
max:
    data 9
dev:
    data 3012


;Fin Datos

;Programas
org 5000
ProgPrincipal:
    or r30, r0, 3000;Inicializamos la pila

    ;bsr TestLongCad
    ;bsr TestBuscaCar
    ;bsr TestBuscaCarHastaFinal
    ;bsr TestCoincidenCar
    bsr TestBuscaMax

    stop
    add r1, r1, 1

;Testers
TestLongCad:
    PUSH(r1);Guardamos retorno

    LEA (r10, cad1)
    PUSH (r10) 
    bsr LongCad
    addu r30, r30, 4;Restauramos pila

    POP(r1)
    jmp(r1);Volvemos a retorno



TestBuscaCar: 
    PUSH(r1);Guardamos dirección de retorno

    LEA(r10, to1)
    ld.bu r10, r10, 0
    PUSH (r10);to

    LEA (r10, from1)
    ld.bu r10, r10, 0
    PUSH (r10);from

    LEA (r10, cad2)
    PUSH (r10);*cadena

    LEA(r10, C1);
    ld.bu r10, r10, 0
    PUSH (r10); C

    bsr BuscaCar
    addu r30, r30, 16;Volvemos al estado de pila anterior
    
    POP(r1);Cogemos la dirección de retorno
    jmp(r1)

TestBuscaCarHastaFinal: 
    PUSH(r1);Guardamos dirección de retorno 
    
    LEA (r10, cad2)
    PUSH (r10) 
    bsr LongCad
    addu r30, r30, 4;Restauramos pila
    PUSH (r29);to = LongCad(cad1)

    LEA (r10, from1)
    ld.bu r10, r10, 0
    PUSH (r10);from

    LEA (r10, cad2)
    PUSH (r10);*cadena

    LEA(r10, C1);
    ld.bu r10, r10, 0
    PUSH (r10); C

    bsr BuscaCar
    addu r30, r30, 16;Volvemos al estado de pila anterior
    
    POP(r1);Cogemos la dirección de retorno
    jmp(r1)
TestCoincidenCar:
    PUSH(r1)
    
    LEA(r2, cad2)
    PUSH(r2); Pasamos cad2

    LEA(r2, cad1)
    PUSH(r2); Pasamos cad1

    bsr CoincidenCad
    addu r30, r30, 8; Restauramos pila

    POP(r1)
    jmp (r1)
TestBuscaMax:
    PUSH(r1)

    LEA(r2, dev)
    PUSH(r2); Pasamos *dev

    LOAD(r2, max)
    PUSH(r2); Pasamos max

    LEA(r2, cad3)
    PUSH(r2); Pasamos *cad

    bsr BuscaMax
    addu r30, r30, 12

    POP(r1)
    jmp(r1)


;Fin Testers

;LongCad (*cadena) -> r29 = Longitud Cadena
LongCad:
    PUSH(r1);Guardamos la dirección de retorno

    or r29, r0, r0	;Inicializamos el contador de palabras
    ld r10, r30, 4;Cargamos direccion de la cadena

sig_carLC:
    
    ld.bu r4, r10, r29; Cargamos el caracter
    cmp r7, r4, r0; Comparamos el caracter r4 con el caracter de final de linea
    bb1 eq, r7, fin_LongCad; Saltar a fin_LongCad si ha leido el final de linea
    ;Si no lo ha hecho
    addu r29, r29, 1; longitud++
    ;addu r10, r10, 1; El puntero avanza al siguiente caracter
    br sig_carLC;

fin_LongCad:
    POP(r1)
    jmp(r1);Volvemos a dirección de retorno
;Fin LongCad

;BuscaCar (caracter, *cadena, from, to ) -> r29 = Posicion absoluta del caracter en cadena[from, to), to si no aparece
BuscaCar:
    PUSH(r1); Guardamos dirección de retorno

    ld.bu r20, r30, 4;Cargamos C en r20
    ld r21, r30, 8; Cargamos ref en r21
    ld.bu r29, r30, 12; Cargamos from en r29
    ld.bu r23, r30, 16; Cargamos to en r23


sig_carBC:
    ld.bu r4, r21, r29; Cargamos el caracter desde from
    cmp r7, r4, r20; Comparamos caracter actual con caracter buscado
    bb1 eq, r7, fin_BuscaCar;Si caracter encontrado
    addu r29, r29, 1;from++
    cmp r8, r29, r23; Comparamos from y to en r8
    bb1 eq, r8, fin_BuscaCar; Si hemos llegado al final
    br sig_carBC; Comprobamos el siguiente caracter

fin_BuscaCar:
    POP(r1)
    jmp(r1);Volvemos a la dirección de retorno
;Fin BuscaCar

;long = CoincidenCad (*cadena1, *cadena2) -> r29 = nº de caracteres que coinciden desde el primero
CoincidenCad:
    PUSH(r1); Guardamos retorno

    ld r2, r30, 4; Cargamos en r2 dirección cad1
    ld r3, r30, 8; Cargamos en r3 dirección cad2
    or r29, r0, r0; r29 = index = 0

sig_carCC:
    ld.bu r5, r2, r29; r5 = car cad1
    ld.bu r6, r3, r29; r6 = car cad2
    cmp r7, r5, r6; Comparamos car1 y car2
    bb0 eq, r7,fin_CoincidenCar;Son diferentes
    ;else
    addu r29, r29, 1; index++
    br sig_carCC

fin_CoincidenCar:
    POP(r1)
    jmp(r1);Volvemos a la dirección de retorno
;Fin CoincidenCar



;rv = BuscaMax( *cad, max, *dev ) -> dev = posicion en ref de la cadena con más coincidentes
BuscaMax: 

    PUSH(r1); Guardamos retorno
    ld r2, r30, 4; r2 = *cad
    ld.bu r3, r30, 8; r3 = max
    or r7, r0, r0; r7 = coincidencia max
    or r8, r0, r0; r8 = index busca
    ld.bu r9, r2, r3; r9 = primer carecter

sig_iteracion:

    ;Guardamos variables locales
    PUSH(r7)

    ;BuscaCar (r9, r2, r8, r3)
    PUSH(r3)
    PUSH(r8)
    PUSH(r2)
    PUSH(r9)
    bsr BuscaCar
    POP(r9)
    POP(r2)
    POP(r8)
    POP(r3)

    ;Rescatamos variables locales
    POP(r7)

    ;if(r29 == r3) -> FIN
BP1:
    cmp r25, r29, r3
    bb1 eq, r25, fin_BuscaMax

    or r8, r29, 0;r8 = r29

    ;if (r8 >= 255) -> FIN
BP2:
    cmp r25, r8, 255
    bb1 ge, r25, fin_BuscaMax

    add r10, r2, r8;*r10 = *r2 + r8 
    add r6, r2, r3; r6 = subcadena fija

    ;Guardamos variables locales
    PUSH(r7)
    PUSH(r3)
    PUSH(r8)
    PUSH(r2)
    PUSH(r9)

    ;CoincideCad(r6, r10)
    PUSH(r10)
    PUSH(r6); Es posible que r6 este mal pasado
    bsr CoincidenCad
    add r30, r30, 8; Eliminamos argumentos de pila

    ;Recogemos variables locales
    POP(r9)
    POP(r2)
    POP(r8)
    POP(r3)
    POP(r7)

    ;if (!(r29 > r7)) -> +4
BP3:
    cmp r25, r29, r7
    bb0 gt, r25, +2
    ;else
    or r7, r29, 0;r7 = r29
    add r8, r8, 1;r8++
    br sig_iteracion
fin_BuscaMax:

    ld.bu r4, r30, 12; r4 = *dev
    ;if (r8 == 0) -> r8 = -1
    cmp r25, r8, 0
    bb0 eq, r25, +2
    ;r8 != 0 -> saltar una linea
    sub r8, r8, 1;r8 = -1 
    st r8, r4, 0; Guardamos r8 en *dev
    POP(r1)
BP4:
    jmp(r1)
    
;Fin BuscaMax
Comprime: jmp(r1)
Descomprime: jmp(r1)
Verifica: jmp (r1)